% proceedings
@string{acm-ccs         = "Proceedings of the ACM Conference on Computer and Communications Security (CCS)"}
@string{acm-eurosys     = "Proceedings of the ACM European Conference on Computer Systems (EuroSys)"}
@string{acm-fse         = "Proceedings of the ACM SIGSOFT Symposium on Foundations of Software Engineering (FSE)"}
@string{acm-issta       = "Proceedings of the International Symposium on Software Testing and Analysis (ISSTA)"}
@string{acm-kdd         = "Proceedings of the ACM SIGKDD International Conference on Knowledge Discovery \& Data Mining"}
@string{acm-plas        = "Proceedings of the ACM SIGPLAN Workshop on Programming Languages and Analysis for Security (PLAS)"}
@string{acm-pldi        = "Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)"}
@string{acm-popl        = "Proceedings of the ACM Symposium on Principles of Programming Languages (POPL)"}
@string{acm-sosp        = "Proceedings of the ACM Symposium on Operating Systems Principles (SOSP)"}
@string{acm-worm        = "Proceedings of the ACM Workshop on Recurring Malcode (WORM)"}
@string{acsac           = "Proceedings of the Annual Computer Security Applications Conference (ACSAC)"}
@string{ase             = "Proceedings of the IEEE/ACM International Conference on Automated Software Engineering (ASE)"}
@string{dimva           = "Proceedings of the Conference on Detection of Intrusions and Malware \& Vulnerability Assessment (DIMVA)"}
@string{esorics         = "Proceedings of the European Symposium on Research in Computer Security (ESORICS)"}
@string{icse            = "Proceedings of the International Conference on Software Engineering (ICSE)"}
@string{ieee-oakland    = "Proceedings of the IEEE Symposium on Security and Privacy"}
@string{isc             = "Proceedings of the Information Security Conference (ISC)"}
@string{isoc-ndss       = "Proceedings of the Symposium on Network and Distributed System Security (NDSS)"}
@string{raid            = "Proceedings of the Symposium on Recent Advances in Intrusion Detection (RAID)"}
@string{spin            = "Proceedings of the International SPIN Workshop on Model Checking of Software"}
@string{usenix-freenix  = "Proceedings of the USENIX Annual Technical Conference, FREENIX Track"}
@string{usenix-hotbots  = "Proceedings of the USENIX Workshop on Hot Topics in Understanding Botnet"}
@string{usenix-hotos    = "Proceedings of the USENIX Workshop on Hot Topics in Operating Systems (HotOS)"}
@string{usenix-leet     = "Proceedings of the USENIX Workshop on Large-Scale Exploits and Emergent Threats (LEET)"}
@string{usenix-lisa     = "Proceedings of the Large Installation System Administration Conference (LISA)"}
@string{usenix-nsdi     = "Proceedings of the USENIX Symposium on Networked Systems Design \& Implementation"}
@string{usenix-osdi     = "Proceedings of the USENIX Symposium on Operating Systems Design and Implementation (OSDI)"}
@string{usenix-security = "Proceedings of the USENIX Security Symposium"}
@string{usenix-woot     = "Proceedings of the USENIX Workshop on Offensive Technologies (WOOT)"}
@string{weis            = "Proceedings of the Workshop on the Economics of Information Security (WEIS)"}
@string{www             = "Proceedings of the International World Wide Web Conference (WWW)"}
% journals
@string{acm-tissec      = "ACM Transactions on Information and System Security (TISSEC)"}
@string{acm-toplas      = "ACM Transactions on Programming Languages and Systems (TOPLAS)"}
@string{acm-web         = "ACM Transactions on the Web"}
@string{cacm            = "Communications of the ACM"}
@string{ieee-tse        = "IEEE Transactions on Software Engineering"}

@misc{misc-sample,
  	title={},
	author={},
	month={},
	year={},
	note={\url{}}
}

@inproceedings{compute-caches,
	author = {Aga Shaizeen and Supreet Jeloka and Arun Subramaniyan and Satish Narayanasamy and David Blaauw and Reetuparna Das},
	title = {Compute Caches},
	year = {2017},
	publisher = {IEEE},
	booktitle = {International Symposium on High Performance Computer Architecture (HPCA)},
	series = {}
}

@inproceedings{synthesis-map,
	author = {Peizong Lee and Zvi M. Kedem},
	title = {Synthesizing linear array algorithms from nested for loop algorithms},
	year = {1988},
	publisher = {IEEE},
	booktitle = {Transactions on Computers},
	series = {}
}

@inproceedings{learning-hash,
	author = {Li Xi and Guosheng Lin and Chunhua Shen and Anton Hengel and Anthony Dick},
	title = {Learning Hash Functions Using Column Generation},
	year = {2013},
	publisher = {PMLR},
	booktitle = {International Conference on Machine Learning},
	series = {}
}


@inproceedings{learning-index,
	author = {Kraska Tim and Alex Beutel and Ed H. Chi and Jeffrey Dean and Neoklis Polyzotis},
	title = {The case for learned index structures},
	year = {2018},
	publisher = {},
	booktitle = {International Conference on Management of Data},
	series = {SIGMOD’18}
}


@inproceedings{tiled-manycore,
	author = {Liu Ye and Shinpei Kato and Masato Edahiro},
	title = {Analysis of memory system of tiled many-core processors},
	year = {2019},
	publisher = {},
	booktitle = { IEEE Access},
	series = {}
}

@article{symbolic-e,
	title={Symbolic execution and program testing},
	author={King, James C},
	journal={Communications of the ACM},
	volume={19},
	number={7},
	pages={385--394},
	year={1976},
	publisher={ACM}
}

@Book{program-synthesis-survey,
author = {Gulwani, Sumit and Polozov, Alex and Singh, Rishabh},
title = {Program Synthesis},
booktitle = {Foundations and Trends in Programming Languages},
year = {2017},
month = {August},
abstract = {Program synthesis is the task of automatically ﬁnding a program in the underlying programming language that satisﬁes the user intent expressed in the form of some speciﬁcation. Since the inception of AI in the 1950s, this problem has been considered the holy grail of Computer Science. Despite inherent challenges in the problem such as ambiguity of user intent and a typically enormous search space of programs, the ﬁeld of program synthesis has developed many diﬀerent techniques that enable program synthesis in diﬀerent real-life application domains. It is now used successfully in software engineering, biological discovery, computer-aided education, end-user programming, and data cleaning. In the last decade, several applications of synthesis in the ﬁeld of programming by examples have been deployed in mass-market industrial products. This survey is a general overview of the state-of-the-art approaches to program synthesis, its applications, and subﬁelds. We discuss the general principles common to all modern synthesis approaches such as syntactic bias, oracle-guided inductive search, and optimization techniques. We then present a literature review covering the four most common state-of-the-art techniques in program synthesis: enumerative search, constraint solving, stochastic search, and deduction-based programming by examples. We conclude with a brief list of future horizons for the ﬁeld.},
publisher = {NOW},
url = {https://www.microsoft.com/en-us/research/publication/program-synthesis/},
pages = {1-119},
volume = {4},
}

@inproceedings{10.1145/1168857.1168907,
author = {Solar-Lezama, Armando and Tancau, Liviu and Bodik, Rastislav and Seshia, Sanjit and Saraswat, Vijay},
title = {Combinatorial Sketching for Finite Programs},
year = {2006},
isbn = {1595934510},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1168857.1168907},
doi = {10.1145/1168857.1168907},
abstract = {Sketching is a software synthesis approach where the programmer develops a partial implementation - a sketch - and a separate specification of the desired functionality. The synthesizer then completes the sketch to behave like the specification. The correctness of the synthesized implementation is guaranteed by the compiler, which allows, among other benefits, rapid development of highly tuned implementations without the fear of introducing bugs.We develop SKETCH, a language for finite programs with linguistic support for sketching. Finite programs include many highperformance kernels, including cryptocodes. In contrast to prior synthesizers, which had to be equipped with domain-specific rules, SKETCH completes sketches by means of a combinatorial search based on generalized boolean satisfiability. Consequently, our combinatorial synthesizer is complete for the class of finite programs: it is guaranteed to complete any sketch in theory, and in practice has scaled to realistic programming problems.Freed from domain rules, we can now write sketches as simpleto-understand partial programs, which are regular programs in which difficult code fragments are replaced with holes to be filled by the synthesizer. Holes may stand for index expressions, lookup tables, or bitmasks, but the programmer can easily define new kinds of holes using a single versatile synthesis operator.We have used SKETCH to synthesize an efficient implementation of the AES cipher standard. The synthesizer produces the most complex part of the implementation and runs in about an hour.},
booktitle = {Proceedings of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {404–415},
numpages = {12},
keywords = {SAT, sketching},
location = {San Jose, California, USA},
series = {ASPLOS XII}
}

  

@article{10.1145/1168917.1168907,
author = {Solar-Lezama, Armando and Tancau, Liviu and Bodik, Rastislav and Seshia, Sanjit and Saraswat, Vijay},
title = {Combinatorial Sketching for Finite Programs},
year = {2006},
issue_date = {December 2006},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {40},
number = {5},
issn = {0163-5980},
url = {https://doi.org/10.1145/1168917.1168907},
doi = {10.1145/1168917.1168907},
abstract = {Sketching is a software synthesis approach where the programmer develops a partial implementation - a sketch - and a separate specification of the desired functionality. The synthesizer then completes the sketch to behave like the specification. The correctness of the synthesized implementation is guaranteed by the compiler, which allows, among other benefits, rapid development of highly tuned implementations without the fear of introducing bugs.We develop SKETCH, a language for finite programs with linguistic support for sketching. Finite programs include many highperformance kernels, including cryptocodes. In contrast to prior synthesizers, which had to be equipped with domain-specific rules, SKETCH completes sketches by means of a combinatorial search based on generalized boolean satisfiability. Consequently, our combinatorial synthesizer is complete for the class of finite programs: it is guaranteed to complete any sketch in theory, and in practice has scaled to realistic programming problems.Freed from domain rules, we can now write sketches as simpleto-understand partial programs, which are regular programs in which difficult code fragments are replaced with holes to be filled by the synthesizer. Holes may stand for index expressions, lookup tables, or bitmasks, but the programmer can easily define new kinds of holes using a single versatile synthesis operator.We have used SKETCH to synthesize an efficient implementation of the AES cipher standard. The synthesizer produces the most complex part of the implementation and runs in about an hour.},
journal = {SIGOPS Oper. Syst. Rev.},
month = oct,
pages = {404–415},
numpages = {12},
keywords = {SAT, sketching}
}

  

@article{10.1145/1168918.1168907,
author = {Solar-Lezama, Armando and Tancau, Liviu and Bodik, Rastislav and Seshia, Sanjit and Saraswat, Vijay},
title = {Combinatorial Sketching for Finite Programs},
year = {2006},
issue_date = {November 2006},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {41},
number = {11},
issn = {0362-1340},
url = {https://doi.org/10.1145/1168918.1168907},
doi = {10.1145/1168918.1168907},
abstract = {Sketching is a software synthesis approach where the programmer develops a partial implementation - a sketch - and a separate specification of the desired functionality. The synthesizer then completes the sketch to behave like the specification. The correctness of the synthesized implementation is guaranteed by the compiler, which allows, among other benefits, rapid development of highly tuned implementations without the fear of introducing bugs.We develop SKETCH, a language for finite programs with linguistic support for sketching. Finite programs include many highperformance kernels, including cryptocodes. In contrast to prior synthesizers, which had to be equipped with domain-specific rules, SKETCH completes sketches by means of a combinatorial search based on generalized boolean satisfiability. Consequently, our combinatorial synthesizer is complete for the class of finite programs: it is guaranteed to complete any sketch in theory, and in practice has scaled to realistic programming problems.Freed from domain rules, we can now write sketches as simpleto-understand partial programs, which are regular programs in which difficult code fragments are replaced with holes to be filled by the synthesizer. Holes may stand for index expressions, lookup tables, or bitmasks, but the programmer can easily define new kinds of holes using a single versatile synthesis operator.We have used SKETCH to synthesize an efficient implementation of the AES cipher standard. The synthesizer produces the most complex part of the implementation and runs in about an hour.},
journal = {SIGPLAN Not.},
month = oct,
pages = {404–415},
numpages = {12},
keywords = {SAT, sketching}
}

  

@article{solar-lezama-sketching,
author = {Solar-Lezama, Armando and Tancau, Liviu and Bodik, Rastislav and Seshia, Sanjit and Saraswat, Vijay},
title = {Combinatorial Sketching for Finite Programs},
year = {2006},
issue_date = {December 2006},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {34},
number = {5},
issn = {0163-5964},
url = {https://doi.org/10.1145/1168919.1168907},
doi = {10.1145/1168919.1168907},
abstract = {Sketching is a software synthesis approach where the programmer develops a partial implementation - a sketch - and a separate specification of the desired functionality. The synthesizer then completes the sketch to behave like the specification. The correctness of the synthesized implementation is guaranteed by the compiler, which allows, among other benefits, rapid development of highly tuned implementations without the fear of introducing bugs.We develop SKETCH, a language for finite programs with linguistic support for sketching. Finite programs include many highperformance kernels, including cryptocodes. In contrast to prior synthesizers, which had to be equipped with domain-specific rules, SKETCH completes sketches by means of a combinatorial search based on generalized boolean satisfiability. Consequently, our combinatorial synthesizer is complete for the class of finite programs: it is guaranteed to complete any sketch in theory, and in practice has scaled to realistic programming problems.Freed from domain rules, we can now write sketches as simpleto-understand partial programs, which are regular programs in which difficult code fragments are replaced with holes to be filled by the synthesizer. Holes may stand for index expressions, lookup tables, or bitmasks, but the programmer can easily define new kinds of holes using a single versatile synthesis operator.We have used SKETCH to synthesize an efficient implementation of the AES cipher standard. The synthesizer produces the most complex part of the implementation and runs in about an hour.},
journal = {SIGARCH Comput. Archit. News},
month = oct,
pages = {404–415},
numpages = {12},
keywords = {SAT, sketching}
}

  

